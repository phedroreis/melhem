<!DOCTYPE html>
<html lang="pt-br">
<head>
  <style>

    body {
      padding: 20px;
    }

    div {
      margin: 50px;
      border-bottom: solid 1px;
    }

     .match {
      color: red;
     }

     ol {
      border: solid 1px;
      width: 120px;
      padding: 8px;
      margin: 20px;
     }

     li:nth-child(odd) {
      background-color: gainsboro;
     }

     pre {
       background-color: gainsboro;
       font-size: 16px;
     }

  </style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algoritmo de busca</title>
</head>
<body>

  <div>
    <p>Ok, já escrevi o programa. Em Java.</p>
    <p>Mas não tenho dados (arquivos) para testar.</p>
    <p>Note que a saída desse programa de teste é no terminal. Ele compara cada nome de arquivo no diretório corrente (e nos seus subdiretórios) com cada outro nome de arquivo também desse diretório ou de algum subdiretório dele. Ou seja, vai comprarar todos os arquivos com todos os outros arquivos a partir do diretório corrente (varrendo também os subdiretórios deste).</p>
    <p>Significa que o arquivo será comparado também com ele mesmo, mas como se exige uma correspondência mínima de 3 palavras, então se o nome deste arquivo tiver menos de 3 palavras, a comparação dele com ele mesmo retornará FALSA.</p>
    <p>E isso é meio que um bug do código. Mas este é só um código pra testes.</p>
    <p>O programa irá considerar, como delimitador de palavras, os seguintes caracteres: ponto, traço, sublinhado e espaço em branco. E não vai diferenciar maiúsculas e minúsculas nas comparações.</p>
    <p>Isto quer dizer que os nomes:</p>
    <p><b><i>colher de chá de açúcar.txt</i></b></p>
    <p>E</p>
    <p><i><b>uma COLHER_DE-CHÁ de café.docx</b></i></p>
    <p>Irão correponder em "colher de chá" para o programa.</p>
    <p>Ele não vai diferenciar "COLHER_DE-CHÁ" de "colher de chá". Portanto estes dois nomes de arquivo dariam match nesse programa.</p>
  </div>

  <div>
    <h3>Como funciona?</h3> <h3>Considere este exemplo:</h3>
    <p>A gente precisaria encontrar o <i>match</i> "banana laranja limao" entre as duas strings a seguir.</p>
    <p>[String source] goiaba <span class="match">banana laranja limao</span> graviola morango</p>
    <p>[String target] manga abacate <del>banana laranja</del> acerola <span class="match">banana laranja limao</span> abacate</p>
  </div>

  <div>
    <p>O primeiro passo seria desmembrar as strings em arrays de palavras, mas preservando a ondem em que elas ocorrem. Assim:</p>
    <h3>Array source</h3>
    <figure>
      <ol start="0">
        <li>goiaba</li>
        <li>banana</li>
        <li>laranja</li>
        <li>limao</li>
        <li>graviola</li>
        <li>morango</li>
      </ol>
      <caption>source.length = 6</caption>
    </figure>
    <h3>Array target</h3>
    <figure>
      <ol start="0">
        <li>manga</li>
        <li>abacate</li>
        <li>banana</li>
        <li>laranja</li>
        <li>acerola</li>
        <li>banana</li>
        <li>laranja</li>
        <li>limao</li>
        <li>abacate</li>
      </ol>
      <caption>target.length = 9</caption>
    </figure>
  </div>

  <div>
    <p>Então executar o algoritmo abaixo para estes dois arrays como entrada. (Corrigi alguns pequenos bugs da versão anterior)</p>
    <pre>
      <code>
      ALGORTIMO

        matchCounter = 0;
        sourceIndex = 0;
        targetIndex = 0;

        ENQUANTO (sourceIndex < source.length E matchCounter < 3) FACA {

          SE (source[sourceIndex] == target[targetIndex]) {

            sourceIndex++;
            matchCounter++;

          } SENAO {

            sourceIndex = sourceIndex - matchCounter;
            matchCounter = 0;

          }

          SE (matcheCounter == 3) {

            IMPRIMA('Deu Match!');

            ENCERRE A EXECUCAO;
          }

          targetIndex++;

          SE (targetIndex == target.length) { 

            sourceIndex++;
            targetIndex = 0; 
            matchCounter = 0;

          }

        }//FIM DO ENQUANTO
    
      FIM DO ALGORITMO
      </code>
    </pre>
  </div>

  <div>
    <p>Pegue lápis e papel.</p>
    <p>Tente executar manualmente o algoritmo pra entender como funciona.</p>
  </div>

  <div>
    <h3>Experimente executar este programa.</h3>

    <p>A saída dele será no terminal, mas podemos fazer uma versão que registre esta saída em um arquivo texto.</p>
    <pre>
      <code>
        import java.io.File;
        import java.util.LinkedList;
        import java.util.List;
        import java.util.StringTokenizer;
        
        
        public final class  FilenameMatch {
            
            /*
            Essa estrutura de dados irah armazenar uma lista com todos os nomes de 
            arquivos no diretorio corrente e em seus subdiretorios
            */
            private static final List<String> LIST = new LinkedList();
            
            /*
            Essa string define os caracteres que serao considerados delimitadores de
            palavras nos nomes de arquivos.
            */
             private static final String TOKENS_DELIMITER = " .-_";
            
            /*
            O numero minimo de palavras que devem coincidir para ser considerao match
            */
            private static final int MATCH_LENGTH = 3;
            
            /*-------------------------------------------------------------------------
                  Um metodo recursivo que insere na estrutura LIST os nomes de todos
                  os arquivos no diretorio dir, passado como paramentro para 
                  este metodo
            --------------------------------------------------------------------------*/    
            public static void getFilenames(File dir) {
                
                   
                File[] fileList = dir.listFiles();
                
                for (File file : fileList) {
                    
                    if (file.isFile()) {
                        
                        /*Se file eh arquivo, insere seu nome em LIST*/
                        
                        LIST.add(file.getName());
                        
                    } else {
                        
                        /*Se file eh subdiretorio, o metodo se chama recursivamente
                        para continuar a pesquisa neste subdiretorio*/
                        
                        getFilenames(file);
                        
                    }            
                }       
                
            }//getFilenames
            
            /*--------------------------------------------------------------------------
               Extrai para um array todos os tokens (palavras) de um nome de arquivo
            --------------------------------------------------------------------------*/
            public static String[] getTokens(String filename) {
                
                StringTokenizer tokenizer = 
                  new StringTokenizer(filename, TOKENS_DELIMITER);
                
                String[] tokensArray = new String[tokenizer.countTokens()];
                
                int countTokens = 0;
                
                while (tokenizer.hasMoreTokens()) {
                      
                    tokensArray[countTokens++] = tokenizer.nextToken(); 
                }
        
                return tokensArray;
                
            }//getTokens
            
            /*-------------------------------------------------------------------------
                  Testa a correspondencia entre a string source (jah convertida para
                  array de tokens) e a string target        
            --------------------------------------------------------------------------*/    
            public static boolean isMatch(String[] sourceArray, String targetStr) {
                
                String[] targetArray = getTokens(targetStr);
                
                int matchCounter = 0;
                int sourceIndex = 0;
                int targetIndex = 0;
                
                while (sourceIndex < sourceArray.length) {
                    
                    if (sourceArray[sourceIndex].equalsIgnoreCase(targetArray[targetIndex])) {
                        
                        sourceIndex++;
                        matchCounter++;
                        
                    } else {
                        
                        sourceIndex = sourceIndex - matchCounter;
                        matchCounter = 0;
                        
                    }//fim do if-else
                    
                    if (matchCounter == MATCH_LENGTH) return true;
                    
                    targetIndex++;
                    
                    if (targetIndex == targetArray.length) {
                        
                        sourceIndex++;
                        targetIndex = 0;
                        matchCounter = 0;
                        
                    }//fim do if
                    
                }//fim do while        
               
                return false;
                
            }//isMatch
            
            /*-------------------------------------------------------------------------
                Recebe o array com os tokens de um nome de arquivo e compara com os
                nomes de todos os arquivos no diretorio corrente e nos seus
                subdiretorios
            
                O parametro dir indica o diretorio de pesquisa
            --------------------------------------------------------------------------*/    
            public static void lookForMatches(String[] sourceArray, File dir) {
                  
                File[] fileList = dir.listFiles();
                
                for (File file : fileList) {
                    
                    if (file.isFile()) {
                        
                        /*Se deu match, escreve o pathname do arquivo que deu match*/
                        
                        if (isMatch(sourceArray, file.getName()))
                            
                            System.out.println(file.getAbsolutePath() + "\n");
                        
                    } else {
                        
                       /*Se file eh subdiretorio, o metodo se chama recursivamente
                        para continuar a pesquisa neste subdiretorio*/
                       
                        lookForMatches(sourceArray, file);
                        
                    }            
                }
                
            }//lookForMatches
        
            /*-------------------------------------------------------------------------
                            Metodo que inicia a execucao do programa       
            --------------------------------------------------------------------------*/
            public static void main(String[] args) {
                
                
                File currentDir = new File(".");//Obtem o diretorio corrente        
                
                /*Obtem uma lista (LIST) com os nomes de todos os arquivos no diretorio
                corrente e nos seus subdiretorios*/        
                getFilenames(currentDir);
                
                /*Percorre todos os nomes de LIST e compara este filename com os nomes
                de todos os outros arquivos no diretorio corrente e seus subdiretorios*/
                for (String filename: LIST) {
                    
                    System.out.println("\nMatches para \"" + filename + "\" : \n");
                    
                    String[] sourceArray = getTokens(filename);
                    
                    lookForMatches(sourceArray, currentDir);
                }
               
            }//main
            
        }//classe FilenameMatch
      </code>
    </pre>
  </div>
  
</body>
</html>
